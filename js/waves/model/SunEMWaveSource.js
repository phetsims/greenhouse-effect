// Copyright 2021, University of Colorado Boulder

/**
 * SunEMWaveSource produces simulated waves of electromagnetic energy (specifically visible light) that move in a
 * downward direction.
 */

import dotRandom from '../../../../dot/js/dotRandom.js';
import Range from '../../../../dot/js/Range.js';
import Vector2 from '../../../../dot/js/Vector2.js';
import GreenhouseEffectConstants from '../../common/GreenhouseEffectConstants.js';
import LayersModel from '../../common/model/LayersModel.js';
import greenhouseEffect from '../../greenhouseEffect.js';
import Wave from './Wave.js';

// constants
const WAVE_DIRECTION = GreenhouseEffectConstants.STRAIGHT_DOWN_NORMALIZED_VECTOR;

// x (horizontal) positions at which light waves can originate, y is assumed to be the top of the atmosphere
const LEFT_SIDE_LIGHT_WAVE_ORIGINS_X = [
  -0.15 * GreenhouseEffectConstants.SUNLIGHT_SPAN,
  -0.25 * GreenhouseEffectConstants.SUNLIGHT_SPAN
];
const RIGHT_SIDE_LIGHT_WAVE_ORIGINS_X = [
  0.25 * GreenhouseEffectConstants.SUNLIGHT_SPAN,
  0.35 * GreenhouseEffectConstants.SUNLIGHT_SPAN
];

const LIGHT_WAVE_ORIGIN_Y = LayersModel.HEIGHT_OF_ATMOSPHERE;
const LIGHT_WAVE_PRODUCTION_TIME_RANGE = new Range(
  LayersModel.HEIGHT_OF_ATMOSPHERE * 1.25 / GreenhouseEffectConstants.SPEED_OF_LIGHT,
  LayersModel.HEIGHT_OF_ATMOSPHERE * 2 / GreenhouseEffectConstants.SPEED_OF_LIGHT
);

class SunEMWaveSource {

  /**
   * @param {Wave[]} wavesInModel
   * @param {SunEnergySource} sunEnergySource
   */
  constructor( wavesInModel, sunEnergySource ) {

    // @private
    this.wavesInModel = wavesInModel;

    // @private {Map.<Wave,number>}
    this.waveToLifetimeMap = new Map();


    // Add the initial waves when the sun starts shining.
    sunEnergySource.isShiningProperty.link( isShining => {

      if ( isShining ) {

        const leftSideInitialWave = new Wave(
          GreenhouseEffectConstants.VISIBLE_WAVELENGTH,
          new Vector2( LEFT_SIDE_LIGHT_WAVE_ORIGINS_X[ 0 ], LIGHT_WAVE_ORIGIN_Y ),
          WAVE_DIRECTION,
          0
        );
        this.wavesInModel.push( leftSideInitialWave );
        this.waveToLifetimeMap.set( leftSideInitialWave, nextRandomWaveLifetime() );

        const rightSideInitialWave = new Wave(
          GreenhouseEffectConstants.VISIBLE_WAVELENGTH,
          new Vector2( RIGHT_SIDE_LIGHT_WAVE_ORIGINS_X[ 0 ], LIGHT_WAVE_ORIGIN_Y ),
          WAVE_DIRECTION,
          0
        );
        this.wavesInModel.push( rightSideInitialWave );
        this.waveToLifetimeMap.set( rightSideInitialWave, nextRandomWaveLifetime() );
      }
    } );
  }

  /**
   * @public
   */
  step() {

    // Loop through a copy of the waves in the model and make updates as needed.
    [ ...this.wavesInModel ].forEach( wave => {
      if ( this.waveToLifetimeMap.has( wave ) ) {

        // This wave was generated by this source.  If it is still being actively produced, check if that should change.
        if ( wave.isSourced ) {
          if ( wave.existanceTime >= this.waveToLifetimeMap.get( wave ) ) {
            wave.isSourced = false;

            // Since this wave has finished being produced, it's time to add a new one.
            const newWave = new Wave(
              GreenhouseEffectConstants.VISIBLE_WAVELENGTH,
              new Vector2( getNextWaveProductionXPosition( wave.origin ), LIGHT_WAVE_ORIGIN_Y ),
              WAVE_DIRECTION,
              0
            );
            this.wavesInModel.push( newWave );
            this.waveToLifetimeMap.set( newWave, nextRandomWaveLifetime() );
          }
        }
      }
    } );
  }
}

// helper function for random wave lifetimes
const nextRandomWaveLifetime = () =>
  dotRandom.nextDoubleBetween( LIGHT_WAVE_PRODUCTION_TIME_RANGE.min, LIGHT_WAVE_PRODUCTION_TIME_RANGE.max );

/**
 * Get the X (horizontal) coordinate from which a wave should originate given the origin of a wave that just finished.
 * @param {Vector2} currentPoint
 * @returns {number}
 */
const getNextWaveProductionXPosition = currentPoint => {
  let sourceArray;
  if ( LEFT_SIDE_LIGHT_WAVE_ORIGINS_X.includes( currentPoint.x ) ) {
    sourceArray = LEFT_SIDE_LIGHT_WAVE_ORIGINS_X;
  }
  else if ( RIGHT_SIDE_LIGHT_WAVE_ORIGINS_X.includes( currentPoint.x ) ) {
    sourceArray = RIGHT_SIDE_LIGHT_WAVE_ORIGINS_X;
  }

  assert && assert( sourceArray, 'unable to find provided point' );

  return sourceArray[ ( sourceArray.indexOf( currentPoint.x ) + 1 ) % sourceArray.length ];
};

// statics
SunEMWaveSource.LIGHT_WAVE_ORIGIN_Y = LIGHT_WAVE_ORIGIN_Y;

greenhouseEffect.register( 'SunEMWaveSource', SunEMWaveSource );
export default SunEMWaveSource;